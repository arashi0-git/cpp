# CPPで学んだこと

##  ❓なぜインスタンス化できないようにするの？
✅**理由１：意味のない使用を防ぐ**
```cpp
AAnimal a;           // ❌ 「動物だけ」ってなんの動物？意味が曖昧
AAnimal* a = new AAnimal(); // ❌ 何の鳴き声を出すのか分からない
```
## ❓virtualをつける意味とは？
✅基底クラスでポインタを扱う時に、デストラクタにvirtualがないと、**派生クラスのデストラクタが呼ばれずメモリリークする可能性**があるため
✅virtualが無いと継承したクラスで関数が呼び出せない基底クラスの関数が呼び出されてしまう。

## ❓純粋仮想関数を作る意味とは
 - ✅純粋仮想関数とは：このクラスでは実装しない。派生クラスで必ず実装するという意味を持たせられる
 - ✅概念を表すクラスを定義できる
 - ✅インスタンス化防止
 - ✅バグ防止（派生クラスで純粋仮想関数を書かなければコンパイルエラーになる）

## ❓オーバーライドとは？
・オーバーライドとは、**基底クラスの仮想関数を、派生クラスで独自の動作に置き換えること**

## 🔧具体例：
```cpp
class Animal {
public:
    virtual void makeSound() const {
        std::cout << "Animal sound" << std::endl;
    }
};
```
「どの動物でも鳴き声を出せる」という抽象的な動作。
↓これを継承したクラスでオーバーライド
```cpp
class Dog : public Animal {
public:
    void makeSound() const { // ← オーバーライド！
        std::cout << "Woof!" << std::endl;
    }
};
```

# ☆インターフェースと抽象クラス
✅抽象クラス：少なくとも１つの純粋仮想関数を含むクラス。  
✅インターフェース：すべての関数が純粋仮想関数で、データメンバーを持たないクラス。c++にはない。抽象クラスで代用される。
```抽象クラス
class Animal {
protected:
    std::string type;
public:
    Animal();                   // 具象コンストラクタ
    virtual ~Animal();          // 仮想デストラクタ
    virtual void makeSound() const = 0;  // 純粋仮想関数
    std::string getType() const;         // 具体関数
};
```
- メンバ変数をもつ
- C++では基底クラスに派生クラスで使う関数を宣言しておく必要があるので、純粋仮想関数にしておけば基底クラスで関数を書かなくてもいい
```インターフェース風（C++にはない）
class IShape {
public:
    virtual ~IShape() {}
    virtual double getArea() const = 0;
    virtual void draw() const = 0;
};
```
- 関数はすべて純粋仮想関数
- メンバ変数をもたない
- 他クラスに「こういう機能を持っているべき」ことを強制するための契約  
インターフェースは状態は持っていないというふわふわした存在