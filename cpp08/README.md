# cpp08で学んだこと
## コンテナとは
c++におけるコンテナは
* 値を複数保持できる
* 要素を追加、削除、検索できる
* "STL(Standard Template Library)"に定義されている

よく使われるコンテナの種類
| コンテナ名         | 特徴                         | 例                        |
| ------------- | -------------------------- | ------------------------ |
| `std::vector` | 可変長の配列。末尾に高速追加できる          | `vector<int> nums;`      |
| `std::list`   | 双方向リスト。挿入・削除に強いがランダムアクセス不可 | `list<string> names;`    |
| `std::deque`  | 両端から高速に追加・削除できる            | `deque<double> dq;`      |
| `std::map`    | キーと値のペアで保持（辞書型）            | `map<string, int> ages;` |
| `std::set`    | 重複しない値の集合                  | `set<int> unique;`       |
| `std::stack`  | LIFO構造（後入れ先出し）             | `stack<char> st;`        |
| `std::queue`  | FIFO構造（先入れ先出し）             | `queue<float> q;`        |

* 動的に要素を増やしたい
* 順番に要素を処理したい
* 要素をキーで整理したい

## C/C++におけるコンテナと配列の違い
配列は固定サイズの連続したメモリ領域
```
int arr[3] = {1,2,3};
```
* サイズは固定
* 要素を手動で管理
* 範囲外アクセスしてもエラーにならない

コンテナは？
```
std::vector<int> vec;
vec.push_back(1);
vec.push_back(2);
```

* サイズをあとから増やせる
* ```vec.size()```でサイズを取得
* ソート、探索などのSTLアルゴリズムと連携しやすい

| 機能          | 配列 (`int arr[10]`) | vector (`std::vector<int>`)   |
| ----------- | ------------------ | ----------------------------- |
| サイズ変更       | ❌ 不可               | ✅ 可能（自動で拡張される）                |
| 範囲外アクセス検出   | ❌ できない             | ✅ `.at()`で検出可能                |
| 要素数の取得      | ❌ `sizeof(arr)`など  | ✅ `.size()`                   |
| 要素追加        | ❌ 不可               | ✅ `.push_back()`              |
| STLアルゴリズム使用 | ❌ 難しい              | ✅ `std::find`, `std::sort` など |
| イテレータ対応     | ❌ 限定的              | ✅ 完全対応                        |

## イテレータとは
イテレータとはコンテナ内での要素の位置を指すもので、ポインタのように扱うことができる。
イテレータを使用することでコンテナ内の種類に依存しないで処理を共通化させることができる
```
std::vector<int> x = {0, 1, 2, 3, 4};

// begin() でコンテナ内の先頭要素を指すイテレータを取得
auto it = x.begin();

// イテレータを使用して要素を出力
std::cout << *it << std::endl;  // 0

// イテレータを1つ進める
++it;

// イテレータを使用して要素を出力
std::cout << *it << std::endl;  // 1
```
イテレータが指す要素を参照するにはポインタのデリファレンス同様に```*```をつける
```
std::vector<int> x = {0, 1, 2, 3, 4};

// end() でコンテナ内の最終要素の1つ先を指すイテレータを取得
for (auto it = x.begin(); it != x.end(); ++it) {
    std::cout << *it << std::endl;
}
```
```end()```で取得するイテレータは最終要素ではなく、最終要素の1つ先であるためのループ終了条件として使用できる