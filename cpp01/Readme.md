# C++01学んだこと<br>
# コンストラクタ　デストラクタ
## 1. コンストラクタについて<br>
➤ オブジェクトが生成されたときに自動的に呼ばれる特別な関数
```
Zombie z("Foo");
```
"foo"という名前でZombieオブジェクトが生成され、そのときにコンストラクタが呼ばれる。

## 2. デフォルトコンストラクタについて  
➤ 引数を取らないコンストラクタのこと  
```
Zombie::Zombie() {
    std::cout << "Default constructor called" << std::endl;
}
```
使い方:
```
Zombie z;
```
引数を渡さずに Zombie を作る場合に使われます。クラスが引数付きのコンストラクタしか持たない場合、明示的にデフォルトコンストラクタも用意しないと、引数なしでインスタンスを作れなくなります。

## 3. 名前付きコンストラクタについて  
➤ 引数を取って、オブジェクトに初期値を設定するコンストラクタ
```
Zombie::Zombie(std::string name) {
    this->name = name;
}
```
使い方:
```
Zombie z("Foo");
```
オブジェクトを生成しながら、nameを"foo"に初期化可能

## 4. デストラクタについて  
➤ オブジェクトが破棄されるときに自動で呼ばれる関数
```
Zombie::~Zombie() {
    std::cout << name << " is destroyed." << std::endl;
}
```
使い道：  

メモリの後始末  

デバッグ（今回の課題のように）

## 🧠 なぜ両方（デフォルト・引数付き）必要？  
* newZombie() などで "Foo" のように名前を渡して初期化するには引数付きが必要  

* randomChump() のように一度 Zombie を作ってから setName() で名前を設定したい場合、デフォルトコンストラクタが必要  

# ヒープとスタックとは
## * 🗂 スタック（Stack） 
* 関数内でのみ使用。処理が終わると不要  

* 大量に作る必要があるとき(スタックだとオーバーフローの可能性あり)

* 関数の中で作成されたローカル変数が使うメモリ領域  

* 自動的に割り当て・解放される  

* スコープを抜けると自動で消える（デストラクタが呼ばれる） 

* 高速で効率的だが、サイズが限られている  
```
void randomChump(std::string name) {
    Zombie z(name);  // スタックに作られる
    z.announce();
} // ←ここでzは自動的に破棄され、デストラクタが呼ばれる
```

## * 🏗 ヒープ（Heap）
* 関数を抜けたあとも必要。不要になるタイミングは製作者が決める  

* new や malloc を使って明示的に確保する動的メモリ領域

* 自分で delete しないとメモリが解放されない

* 大量のメモリを柔軟に扱えるが、手動で管理する必要がある
```
Zombie* z = new Zombie("Foo"); // ヒープに作成
z->announce();
delete z; // 手動でメモリを解放、デストラクタが呼ばれる
```

## 🧠 使い分けの基準（まとめ）
| 判断基準 | スタック | ヒープ |
|---------|--------|---------|
| 寿命が短くて、関数内だけで完結 | ✅ 使う | ✖ 不適切 |
| 関数から戻っても使いたい | ✖ 不適 | ✅ ヒープが必要 |
| 数が少ない or 軽い処理 | ✅ OK | ✖ 不必要なヒープ管理になる |
| 大量に作る or 長く使う可能性あり | ✖ スタックオーバーフローの危険 | ✅ 安全 |
| 明示的にメモリ解放したい | ✖（自動で解放） | ✅（deleteが必要）|
