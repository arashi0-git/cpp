# C++01学んだこと<br>
# コンストラクタ　デストラクタ
## 1. コンストラクタについて<br>
➤ オブジェクトが生成されたときに自動的に呼ばれる特別な関数
```
Zombie z("Foo");
```
"foo"という名前でZombieオブジェクトが生成され、そのときにコンストラクタが呼ばれる。

## 2. デフォルトコンストラクタについて  
➤ 引数を取らないコンストラクタのこと  
```
Zombie::Zombie() {
    std::cout << "Default constructor called" << std::endl;
}
```
使い方:
```
Zombie z;
```
引数を渡さずに Zombie を作る場合に使われます。クラスが引数付きのコンストラクタしか持たない場合、明示的にデフォルトコンストラクタも用意しないと、引数なしでインスタンスを作れなくなります。

## 3. 名前付きコンストラクタについて  
➤ 引数を取って、オブジェクトに初期値を設定するコンストラクタ
```
Zombie::Zombie(std::string name) {
    this->name = name;
}
```
使い方:
```
Zombie z("Foo");
```
オブジェクトを生成しながら、nameを"foo"に初期化可能

## 4. デストラクタについて  
➤ オブジェクトが破棄されるときに自動で呼ばれる関数
```
Zombie::~Zombie() {
    std::cout << name << " is destroyed." << std::endl;
}
```
使い道：  

メモリの後始末  

デバッグ（今回の課題のように）

## 🧠 なぜ両方（デフォルト・引数付き）必要？  
* newZombie() などで "Foo" のように名前を渡して初期化するには引数付きが必要  

* randomChump() のように一度 Zombie を作ってから setName() で名前を設定したい場合、デフォルトコンストラクタが必要  

# ヒープとスタックとは
## * 🗂 スタック（Stack） 
* 関数内でのみ使用。処理が終わると不要  

* 大量に作る必要があるとき(スタックだとオーバーフローの可能性あり)

* 関数の中で作成されたローカル変数が使うメモリ領域  

* 自動的に割り当て・解放される  

* スコープを抜けると自動で消える（デストラクタが呼ばれる） 

* 高速で効率的だが、サイズが限られている  
```
void randomChump(std::string name) {
    Zombie z(name);  // スタックに作られる
    z.announce();
} // ←ここでzは自動的に破棄され、デストラクタが呼ばれる
```

## * 🏗 ヒープ（Heap）
* 関数を抜けたあとも必要。不要になるタイミングは製作者が決める  

* new や malloc を使って明示的に確保する動的メモリ領域

* 自分で delete しないとメモリが解放されない

* 大量のメモリを柔軟に扱えるが、手動で管理する必要がある
```
Zombie* z = new Zombie("Foo"); // ヒープに作成
z->announce();
delete z; // 手動でメモリを解放、デストラクタが呼ばれる
```

## 🧠 使い分けの基準（まとめ）
| 判断基準 | スタック | ヒープ |
|---------|--------|---------|
| 寿命が短くて、関数内だけで完結 | ✅ 使う | ✖ 不適切 |
| 関数から戻っても使いたい | ✖ 不適 | ✅ ヒープが必要 |
| 数が少ない or 軽い処理 | ✅ OK | ✖ 不必要なヒープ管理になる |
| 大量に作る or 長く使う可能性あり | ✖ スタックオーバーフローの危険 | ✅ 安全 |
| 明示的にメモリ解放したい | ✖（自動で解放） | ✅（deleteが必要）|

## newとdelete
```
Zombie* horde = new Zombie[5];  // ← Zombie() が5回呼ばれる
...
delete[] horde;                // ← Zombie::~Zombie() が5回呼ばれる
```
#### 必ずnewで複数作成したときは
```
delete[] horde;
delete horde;  // ← NG！
```
#### で開放する必要あり。

## ☆ポインタと参照
### C言語のときに曖昧のまま進んだ自分よここで学ぶチャンスだ！！  
ポインタ (*) | 参照 (&)
|-----------|--------|
指す先を変更できる | 再代入（指す先の変更）はできない
NULL や未初期化が可能 | 初期化必須、NULL不可
間接的に値を変更できる | 別名として直接値を変更できる
より柔軟だが危険も多い | 安全だが柔軟性は少なめ

項目 | 参照（reference） | ポインタ（pointer）
|--|-------------------|-----------------|
再代入 | ❌ 一度バインドしたら変更不可 | ✅ 指す先を後から変更できる
NULL | ❌ NULLになれない | ✅ NULLポインタにできる
初期化 | ✅ 初期化必須 | ✅ 初期化しなくても宣言できる
構文 | . を使う（自然な記法） | * や -> を使う
安全性 | ✅ 比較的安全 | ⚠️ 間違えるとバグやクラッシュ
柔軟性 | 🔸 限定的 | ✅ 高い

* 参照を使うべき場面
1. 関数の引数として使う（値をコピーせずに渡したい）
```
void modify(std::string& str) {
    str += " world";
}
```
2. 関数の戻り値として、元の変数を返したい
```
int& getRef(int& x) {
    return x;  // xへの参照を返す
}
```
3. オブジェクトの別名をつけたい
```
int& getRef(int& x) {
    return x;  // xへの参照を返す
}
```

* ポインタを使うべき場面（柔軟に操作したい時）
1. 動的メモリ確保
```
int* arr = new int[10];  // ポインタでヒープメモリを扱う
```
2. 可変の参照（再代入）
```
void setTo(int* ptr, int* newTarget) {
    ptr = newTarget;  // 別のアドレスに切り替えたい
}
```
3. NULLで何も指していない状態を表したい時
```
Node* next = NULL;
if (next == NULL) { /* ... */ }
```

4. 配列・リスト・ツリー構造などの実装
```
struct Node {
    int data;
    Node* next;
};
```
## ✅ 実際の使い分けのルール
状況 | おすすめ
|----|-----|
関数でデータを変更したい（簡単に） | 参照
引数がNULLになる可能性がある | ポインタ
動的にオブジェクトを作る/破棄する必要がある | ポインタ
安全で読みやすいコードを書きたい | 参照
複雑なデータ構造を作りたい（ツリー、リスト） | ポインタ